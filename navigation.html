<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Navigation ‚Äî Site Navigator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0078ff" />

  <!-- Mapbox -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.15.0/mapbox-gl.js"></script>

  <!-- Turf -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
    :root{
      --card-bg: rgba(18,18,18,0.92);
      --card-bg-2: rgba(24,24,24,0.92);
      --text: #fff;
      --muted: rgba(255,255,255,0.78);
      --muted2: rgba(255,255,255,0.62);
      --accent: #0a84ff;
      --danger: #ff453a;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 18px;
    }

    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #000;
      overflow: hidden;
    }

    #map {
      position: absolute;
      inset: 0;
    }

    /* GPS Overlay */
    #enableGPS {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.70);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
    }
    #enableGPS button {
      background: #00b35a;
      color: #fff;
      font-size: 18px;
      padding: 14px 26px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      box-shadow: var(--shadow);
    }

    /* Top instruction card (Apple-ish) */
    #topCard {
      position: absolute;
      left: 12px;
      right: 12px;
      top: 10px;
      z-index: 40;
      pointer-events: none;
    }

    #instructionCard {
      background: var(--card-bg);
      color: var(--text);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px 14px;
      display: flex;
      gap: 12px;
      align-items: center;
      backdrop-filter: blur(10px);
    }

    #maneuverIcon {
      width: 46px;
      height: 46px;
      border-radius: 14px;
      background: rgba(255,255,255,0.10);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      flex: 0 0 auto;
    }

    #maneuverMain {
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 3px;
      flex: 1 1 auto;
    }

    #maneuverDistance {
      font-size: 26px;
      font-weight: 800;
      letter-spacing: -0.02em;
      line-height: 1.05;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #maneuverInstruction {
      font-size: 15px;
      font-weight: 650;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #maneuverThen {
      margin-top: 8px;
      background: var(--card-bg-2);
      color: var(--muted2);
      border-radius: 14px;
      padding: 10px 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
    }

    /* Bottom sheet (trip strip + step list) */
    #bottomSheet {
      position: absolute;
      left: 12px;
      right: 12px;
      bottom: 12px;
      z-index: 45;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: auto;
    }

    #tripStrip {
      background: var(--card-bg);
      color: var(--text);
      border-radius: 22px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      padding: 10px 12px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #grabArea {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1 1 auto;
      min-width: 0;
      cursor: pointer;
      user-select: none;
    }

    #grabHandle {
      width: 34px;
      height: 5px;
      border-radius: 999px;
      background: rgba(255,255,255,0.22);
      flex: 0 0 auto;
      margin-left: 4px;
    }

    .tripMetric {
      display: flex;
      flex-direction: column;
      line-height: 1.1;
      min-width: 72px;
    }
    .tripMetric .val {
      font-size: 18px;
      font-weight: 750;
      letter-spacing: -0.02em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .tripMetric .lbl {
      font-size: 11px;
      color: var(--muted2);
      margin-top: 3px;
    }

    #btnEnd {
      background: var(--danger);
      color: #fff;
      border: none;
      border-radius: 14px;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
      flex: 0 0 auto;
    }

    #stepsPanel {
      background: var(--card-bg);
      color: var(--text);
      border-radius: 22px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      overflow: hidden;
      max-height: 0px;
      transition: max-height 220ms ease;
    }

    #bottomSheet.expanded #stepsPanel {
      max-height: 340px;
    }

    #stepsHeader {
      padding: 12px 14px 8px 14px;
      font-size: 12px;
      color: var(--muted2);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #stepsList {
      max-height: 300px;
      overflow: auto;
      padding: 6px 10px 12px 10px;
    }

    .stepRow {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 10px;
      border-radius: 14px;
      margin: 6px 0;
      background: rgba(255,255,255,0.06);
    }
    .stepRow.active {
      background: rgba(10,132,255,0.25);
      outline: 1px solid rgba(10,132,255,0.35);
    }

    .stepIcon {
      width: 30px;
      height: 30px;
      border-radius: 12px;
      background: rgba(255,255,255,0.10);
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 auto;
      font-size: 16px;
    }

    .stepText {
      flex: 1 1 auto;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .stepText .primary {
      font-size: 13px;
      font-weight: 650;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .stepText .secondary {
      font-size: 11px;
      color: var(--muted2);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .stepDist {
      font-size: 12px;
      color: var(--muted);
      flex: 0 0 auto;
      white-space: nowrap;
      margin-left: 6px;
    }

    /* Arrow marker: rotate inner child only */
    .arrow-marker {
      width: 28px;
      height: 28px;
      position: relative;
    }
    .arrow-rotor {
      width: 28px;
      height: 28px;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><polygon points="50,0 90,100 50,80 10,100" fill="%230078ff"/></svg>');
      background-size: contain;
      background-repeat: no-repeat;
      transform-origin: center center;
      transition: transform .07s linear;
      will-change: transform;
    }
    .arrow-active .arrow-rotor {
      filter: hue-rotate(90deg) brightness(1.3);
    }

    /* Recenter FAB */
    #recenterFab {
      position: absolute;
      right: 16px;
      bottom: 140px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 2px 10px rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 46;
      backdrop-filter: blur(8px);
    }
    #recenterFab::before {
      content: "";
      width: 24px;
      height: 24px;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="160" height="160" viewBox="0 0 24 24"><path fill="%230078ff" d="M12 8l4 4-4 4-1.41-1.41L12.17 13H4v-2h8.17l-1.58-1.59z"/></svg>')
        no-repeat center/contain;
      transform: rotate(-90deg);
    }
  </style>
</head>
<body>

  <div id="map"></div>

  <div id="enableGPS">
    <button id="btnEnableGPS">Enable GPS</button>
  </div>

  <div id="topCard">
    <div id="instructionCard">
      <div id="maneuverIcon">‚¨ÜÔ∏è</div>
      <div id="maneuverMain">
        <div id="maneuverDistance">‚Äî</div>
        <div id="maneuverInstruction">Loading‚Ä¶</div>
      </div>
    </div>
    <div id="maneuverThen">Then: ‚Äî</div>
  </div>

  <div id="bottomSheet">
    <div id="tripStrip">
      <div id="grabArea" title="Tap to show steps">
        <div id="grabHandle"></div>

        <div class="tripMetric">
          <div class="val" id="arriveVal">‚Äî</div>
          <div class="lbl">arrival</div>
        </div>

        <div class="tripMetric">
          <div class="val" id="timeVal">‚Äî</div>
          <div class="lbl">time</div>
        </div>

        <div class="tripMetric">
          <div class="val" id="distVal">‚Äî</div>
          <div class="lbl">distance</div>
        </div>
      </div>

      <button id="btnEnd">End</button>
    </div>

    <div id="stepsPanel">
      <div id="stepsHeader">
        <span>Directions</span>
        <span id="stepsMeta">‚Äî</span>
      </div>
      <div id="stepsList"></div>
    </div>
  </div>

  <div id="recenterFab"></div>

  <script>
    const CAN_SERVER_LOG =
      location.hostname === "localhost" ||
      location.hostname === "127.0.0.1" ||
      /^\d{1,3}(\.\d{1,3}){3}$/.test(location.hostname);

    function logToServer(level, msg) {
      if (!CAN_SERVER_LOG) return Promise.resolve();
      return fetch("./log", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ level, msg })
      }).catch(() => {});
    }

    const log = (...a) => { console.log(...a); logToServer("LOG", a.join(" ")); };
    const err = (...a) => { console.error(...a); logToServer("ERROR", a.join(" ")); };
  </script>

  <script type="module">
    import {
      SITE_DATA,
      fetchDistanceMatrix,
      greedyOrder,
      fetchRouteGeoJSON,
      drawRoute,
      fitToRoute,
      clearRoute
    } from "./route-planner.js";

    log("navigation.html loaded");

    function getURLOverrideStart() {
      const params = new URLSearchParams(window.location.search);
      if (!params.has("start")) return null;

      const parts = params.get("start").split(",");
      if (parts.length !== 2) return null;

      const lng = parseFloat(parts[0]);
      const lat = parseFloat(parts[1]);
      if (isNaN(lng) || isNaN(lat)) return null;

      log("‚ö† URL Override: Using custom start:", lng, lat);
      return [lng, lat];
    }

    const urlOverrideStart = getURLOverrideStart();

    const siteName = localStorage.getItem("selectedSite");
    const excluded = JSON.parse(localStorage.getItem("excludedTurbines") || "[]");

    if (!siteName || !SITE_DATA[siteName]) {
      alert("No site selected.");
      window.location.href = "index.html";
    }

    const site = SITE_DATA[siteName];
    const points = {};
    for (const [tName, coords] of Object.entries(site.points)) {
      if (!excluded.includes(tName)) points[tName] = coords;
    }

    const stopNames = Object.keys(points);
    if (stopNames.length === 0) {
      alert("You excluded every turbine ‚Äî no navigation possible.");
      window.location.href = "exclude.html";
    }

    log("Selected site:", siteName);
    log("Included turbines:", stopNames.join(", "));

    mapboxgl.accessToken = "pk.eyJ1IjoieW91cmVsZGVyIiwiYSI6ImNtaDhxZHg1bTAxeWkyaXB5aTAyM2ZyY3gifQ.pkTMlQzTDcgl2pvIGyP1Jw";

    let avgLng = 0, avgLat = 0;
    stopNames.forEach(n => { avgLng += points[n][0]; avgLat += points[n][1]; });
    avgLng /= stopNames.length;
    avgLat /= stopNames.length;

    const map = new mapboxgl.Map({
      container: "map",
      style: "mapbox://styles/mapbox/streets-v12",
      center: [avgLng, avgLat],
      zoom: 12
    });

    map.on("load", () => log("Map loaded"));

    const gpsOverlay = document.getElementById("enableGPS");
    const btnEnableGPS = document.getElementById("btnEnableGPS");

    const maneuverIconEl = document.getElementById("maneuverIcon");
    const maneuverDistanceEl = document.getElementById("maneuverDistance");
    const maneuverInstructionEl = document.getElementById("maneuverInstruction");
    const maneuverThenEl = document.getElementById("maneuverThen");

    const bottomSheet = document.getElementById("bottomSheet");
    const grabArea = document.getElementById("grabArea");
    const stepsListEl = document.getElementById("stepsList");
    const stepsMetaEl = document.getElementById("stepsMeta");

    const arriveVal = document.getElementById("arriveVal");
    const timeVal = document.getElementById("timeVal");
    const distVal = document.getElementById("distVal");
    const btnEnd = document.getElementById("btnEnd");

    const recenterFab = document.getElementById("recenterFab");

    // STATE
    let userPos = null;          // raw GPS pos used for nav logic + UI calcs
    let headingDeg = null;       // 0..360 true heading when available

    let followUser = true;
    let navActive = false;

    let arrowMapboxMarker = null;
    let arrowRotorEl = null;

    let navRoute = null;
    let routeLine = null;
    let steps = [];
    let stepIdx = 0;

    const MANEUVER_RADIUS_M = 18;
    const METERS_PER_MILE = 1609.344;

    // Off-route reroute
    let lastOffRouteCheck = 0;
    let offRouteStrikes = 0;
    let rerouteInProgress = false;

    // Smoothing state
    let gpsTarget = null;
    let smoothPos = null;
    let lastAnimT = 0;
    let animStarted = false;

    // When user interacts with map, freeze smoothing to avoid ‚Äúfloat‚Äù
    let freezeMarker = false;

    // HELPERS
    function miles(meters) { return meters / METERS_PER_MILE; }

    function formatMiles(mi) {
      if (mi < 0.1) return `${Math.round(mi * 5280)} ft`;
      if (mi < 10) return `${mi.toFixed(1)} mi`;
      return `${mi.toFixed(0)} mi`;
    }

    function formatDuration(sec) {
      if (!sec || sec <= 0) return "0 min";
      const m = Math.round(sec / 60);
      if (m < 60) return `${m} min`;
      const h = Math.floor(m / 60);
      const r = m % 60;
      return r ? `${h} h ${r} min` : `${h} h`;
    }

    function formatArrivalTime(secondsRemaining) {
      if (!secondsRemaining || secondsRemaining <= 0) return "‚Äî";
      const d = new Date(Date.now() + secondsRemaining * 1000);
      return d.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" });
    }

    function flattenSteps(route) {
      const out = [];
      for (const leg of route.legs || []) for (const s of leg.steps || []) out.push(s);
      return out;
    }

    function maneuverEmoji(m) {
      const type = (m?.type || "").toLowerCase();
      const mod = (m?.modifier || "").toLowerCase();

      if (type === "turn") {
        if (mod === "left" || mod === "slight left" || mod === "sharp left") return "‚¨ÖÔ∏è";
        if (mod === "right" || mod === "slight right" || mod === "sharp right") return "‚û°Ô∏è";
        return "‚Ü©Ô∏è";
      }
      if (type === "merge") return "‚ÜóÔ∏è";
      if (type === "roundabout" || type === "rotary") return "‚≠ï";
      if (type === "fork") {
        if (mod.includes("left")) return "‚ÜñÔ∏è";
        if (mod.includes("right")) return "‚ÜóÔ∏è";
        return "üîÄ";
      }
      if (type === "ramp") return "üõ£Ô∏è";
      if (type === "exit") return "‚§¥Ô∏è";
      if (type === "arrive") return "üèÅ";
      return "‚¨ÜÔ∏è";
    }

    function norm360(d) {
      d = d % 360;
      return d < 0 ? d + 360 : d;
    }

    function applyHeadingToArrow() {
      if (!arrowRotorEl) return;

      if (headingDeg == null) {
        arrowRotorEl.style.transform = `rotate(0deg)`;
        return;
      }

      const mapBearing = map.getBearing();
      const rot = norm360(headingDeg - mapBearing);
      arrowRotorEl.style.transform = `rotate(${rot}deg)`;
    }

    async function enableHeadingSensorsIfNeeded() {
      const DOE = window.DeviceOrientationEvent;
      if (DOE && typeof DOE.requestPermission === "function") {
        try {
          const res = await DOE.requestPermission();
          log("DeviceOrientation permission:", res);
        } catch (e) {
          err("DeviceOrientation permission error:", e);
        }
      }
    }

    function handleDeviceOrientation(e) {
      let h = null;
      if (typeof e.webkitCompassHeading === "number") h = e.webkitCompassHeading;
      else if (typeof e.alpha === "number") h = e.alpha;

      if (h != null) {
        headingDeg = norm360(h);
        applyHeadingToArrow();
        if (followUser) updateCamera(smoothPos || userPos);
      }
    }

    function leadPoint([lng, lat], bearingDeg, metersAhead = 60) {
      const pt = turf.point([lng, lat]);
      const dest = turf.destination(pt, metersAhead / 1000, bearingDeg, { units: "kilometers" });
      return dest.geometry.coordinates;
    }

    function updateCamera(centerOverride = null) {
      const pos = centerOverride || userPos;
      if (!followUser || !pos) return;

      const bearing = (headingDeg != null) ? headingDeg : map.getBearing();
      const center = leadPoint(pos, bearing, 70);

      map.easeTo({
        center,
        bearing,
        pitch: 55,
        zoom: 16,
        duration: 250,
        easing: t => t
      });
    }

    map.on("rotate", applyHeadingToArrow);
    map.on("pitch", applyHeadingToArrow);

    // ===== NEW: along-route distance to maneuver (prevents ‚Äúcounting up‚Äù off-route) =====
    function distanceAlongRouteMeters(line, userLngLat, maneuverLngLat) {
      if (!line || !userLngLat || !maneuverLngLat) return null;

      const userSnap = turf.nearestPointOnLine(line, turf.point(userLngLat), { units: "meters" });
      const manSnap  = turf.nearestPointOnLine(line, turf.point(maneuverLngLat), { units: "meters" });

      const userD = userSnap?.properties?.location;
      const manD  = manSnap?.properties?.location;

      if (!Number.isFinite(userD) || !Number.isFinite(manD)) return null;

      // If user is past the maneuver along the route, do not let distance increase
      if (userD >= manD) return 0;

      const slice = turf.lineSliceAlong(line, userD, manD, { units: "meters" });
      return turf.length(slice, { units: "meters" });
    }

    // Smooth animation loop
    function lerp(a, b, t) { return a + (b - a) * t; }

    function animate(t) {
      if (!animStarted) return;

      if (!lastAnimT) lastAnimT = t;
      const dt = (t - lastAnimT) / 1000;
      lastAnimT = t;

      // If user is interacting with map, do NOT keep easing marker toward gpsTarget
      // This removes the ‚Äúfloat away then settle‚Äù effect.
      if (freezeMarker) {
        if (arrowMapboxMarker && userPos) arrowMapboxMarker.setLngLat(userPos);
        applyHeadingToArrow();
        requestAnimationFrame(animate);
        return;
      }

      if (gpsTarget) {
        if (!smoothPos) smoothPos = gpsTarget.slice();

        const k = 1 - Math.pow(0.001, dt);
        smoothPos = [
          lerp(smoothPos[0], gpsTarget[0], k),
          lerp(smoothPos[1], gpsTarget[1], k)
        ];

        if (arrowMapboxMarker) arrowMapboxMarker.setLngLat(smoothPos);

        applyHeadingToArrow();

        if (followUser) updateCamera(smoothPos);
      }

      requestAnimationFrame(animate);
    }

    function updateNavUI() {
      if (!navActive || !steps.length) return;

      const step = steps[Math.min(stepIdx, steps.length - 1)];
      const maneuver = step.maneuver || {};

      maneuverIconEl.textContent = maneuverEmoji(maneuver);
      maneuverInstructionEl.textContent = maneuver.instruction || maneuver.type || "Continue";

      // ===== UPDATED: distance to maneuver uses along-route distance (fallback to straight-line) =====
      if (userPos && maneuver.location) {
        const dM = distanceAlongRouteMeters(routeLine, userPos, maneuver.location);
        if (Number.isFinite(dM)) {
          maneuverDistanceEl.textContent = formatMiles(miles(dM));
        } else {
          const dMi = turf.distance(turf.point(userPos), turf.point(maneuver.location), { units: "miles" });
          maneuverDistanceEl.textContent = formatMiles(dMi);
        }
      } else {
        maneuverDistanceEl.textContent = "‚Äî";
      }

      const next = steps[Math.min(stepIdx + 1, steps.length - 1)];
      const nextInstr = next?.maneuver?.instruction || next?.maneuver?.type || "‚Äî";
      maneuverThenEl.textContent = `Then: ${nextInstr}`;

      let remMeters = 0, remSeconds = 0;
      for (let i = stepIdx; i < steps.length; i++) {
        remMeters += steps[i].distance || 0;
        remSeconds += steps[i].duration || 0;
      }

      arriveVal.textContent = formatArrivalTime(remSeconds);
      timeVal.textContent = formatDuration(remSeconds);
      distVal.textContent = formatMiles(miles(remMeters));

      stepsMetaEl.textContent = `${Math.min(stepIdx + 1, steps.length)} / ${steps.length}`;

      renderStepsList();
    }

    function renderStepsList() {
      if (!steps.length) { stepsListEl.innerHTML = ""; return; }

      const start = Math.max(0, stepIdx - 1);
      const end = Math.min(steps.length, stepIdx + 9);

      stepsListEl.innerHTML = "";

      for (let i = start; i < end; i++) {
        const s = steps[i];
        const m = s.maneuver || {};
        const row = document.createElement("div");
        row.className = "stepRow" + (i === stepIdx ? " active" : "");

        const icon = document.createElement("div");
        icon.className = "stepIcon";
        icon.textContent = maneuverEmoji(m);

        const txt = document.createElement("div");
        txt.className = "stepText";

        const primary = document.createElement("div");
        primary.className = "primary";
        primary.textContent = m.instruction || m.type || "Continue";

        const secondary = document.createElement("div");
        secondary.className = "secondary";
        secondary.textContent = s.name ? `Road: ${s.name}` : " ";

        txt.appendChild(primary);
        txt.appendChild(secondary);

        const dist = document.createElement("div");
        dist.className = "stepDist";
        dist.textContent = formatMiles(miles(s.distance || 0));

        row.appendChild(icon);
        row.appendChild(txt);
        row.appendChild(dist);

        stepsListEl.appendChild(row);
      }
    }

    function maybeAdvanceStep() {
      if (!navActive || !steps.length || stepIdx >= steps.length - 1) return;

      const step = steps[stepIdx];
      const maneuver = step.maneuver;
      if (!maneuver?.location || !userPos) return;

      const distMi = turf.distance(turf.point(userPos), turf.point(maneuver.location), { units:"miles" });
      const distM = distMi * METERS_PER_MILE;

      if (distM <= MANEUVER_RADIUS_M) {
        stepIdx = Math.min(stepIdx + 1, steps.length - 1);
        updateNavUI();
      }
    }

    function metersOffRoute(line, pos) {
      if (!line || !pos) return 0;
      const snapped = turf.nearestPointOnLine(line, turf.point(pos), { units: "meters" });
      return snapped?.properties?.dist ?? 0;
    }

    async function maybeReroute() {
      if (!navActive || !routeLine || !userPos) return;
      if (rerouteInProgress) return;

      const now = Date.now();
      if (now - lastOffRouteCheck < 2500) return;
      lastOffRouteCheck = now;

      const offM = metersOffRoute(routeLine, userPos);

      if (offM > 60) offRouteStrikes++;
      else offRouteStrikes = Math.max(0, offRouteStrikes - 1);

      if (offRouteStrikes >= 3) {
        offRouteStrikes = 0;
        rerouteInProgress = true;
        try {
          log("Off-route detected. Rerouting‚Ä¶");
          await buildRouteFromUser();

          // ===== NEW: hard reset UI after reroute so we never show stale step distance =====
          stepIdx = 0;
          updateNavUI();

        } catch (e) {
          err("Reroute failed:", e?.message || e);
        } finally {
          rerouteInProgress = false;
        }
      }
    }

    function routeLength(order, mat) {
      let sum = 0;
      for (let i = 0; i < order.length - 1; i++) sum += mat[order[i]][order[i + 1]];
      return sum;
    }

    function twoOpt(order, mat) {
      const n = order.length;
      let bestOrder = order.slice();
      let bestDist = routeLength(bestOrder, mat);
      let improved = true;

      while (improved) {
        improved = false;
        for (let i = 0; i < n - 2; i++) {
          for (let k = i + 2; k < n; k++) {
            const newOrder = bestOrder.slice();
            const segment = newOrder.slice(i + 1, k + 1).reverse();
            newOrder.splice(i + 1, k - i, ...segment);

            const newDist = routeLength(newOrder, mat);
            if (newDist + 1e-6 < bestDist) {
              bestDist = newDist;
              bestOrder = newOrder;
              improved = true;
            }
          }
        }
      }
      return bestOrder;
    }

    async function buildRouteFromUser() {
      if (!userPos) throw new Error("User location not ready");

      const keysAll = Object.keys(points);
      const coordsAll = keysAll.map(k => points[k]);
      const N = coordsAll.length;

      const MAX_TURBINES = 24;
      const CHUNK = 24;
      const BLOCK = 12;

      const userToAll = [];
      for (let i = 0; i < N; i += CHUNK) {
        const chunkKeys = keysAll.slice(i, i + CHUNK);
        const chunkCoords = coordsAll.slice(i, i + CHUNK);

        const m = await fetchDistanceMatrix([userPos, ...chunkCoords], mapboxgl.accessToken);
        for (let j = 0; j < chunkKeys.length; j++) {
          const d = m[0][j + 1];
          userToAll.push({ key: chunkKeys[j], coord: chunkCoords[j], dist: d });
        }
      }

      const reachable = userToAll.filter(x => Number.isFinite(x.dist));
      if (reachable.length === 0) throw new Error("No reachable turbines by driving distance from user.");

      reachable.sort((a, b) => a.dist - b.dist);

      const chosen = reachable.slice(0, Math.min(MAX_TURBINES, reachable.length));
      const keys = chosen.map(x => x.key);
      const turbineCoords = chosen.map(x => x.coord);
      const n = turbineCoords.length;

      const bestFirstIdx = 0;
      log("First turbine (by road):", keys[bestFirstIdx], `(${(chosen[0].dist / 1609.344).toFixed(2)} mi)`);

      const subMatrix = Array.from({ length: n }, () => Array(n).fill(Infinity));
      for (let i = 0; i < n; i++) subMatrix[i][i] = 0;

      const blocks = [];
      for (let i = 0; i < n; i += BLOCK) blocks.push([...Array(Math.min(BLOCK, n - i)).keys()].map(k => i + k));

      for (const A of blocks) {
        for (const B of blocks) {
          const coordsCall = A.map(idx => turbineCoords[idx]).concat(B.map(idx => turbineCoords[idx]));
          const m = await fetchDistanceMatrix(coordsCall, mapboxgl.accessToken);

          for (let ai = 0; ai < A.length; ai++) {
            for (let bj = 0; bj < B.length; bj++) {
              const d = m[ai][A.length + bj];
              if (Number.isFinite(d)) subMatrix[A[ai]][B[bj]] = d;
            }
          }
        }
      }

      let orderIdx = greedyOrder(subMatrix, bestFirstIdx);
      orderIdx = twoOpt(orderIdx, subMatrix);

      const orderedCoords = orderIdx.map(i => turbineCoords[i]);
      const orderedNames = orderIdx.map(i => keys[i]);

      const allCoords = [userPos, ...orderedCoords];
      log("Route order (TSP):", orderedNames.join(" ‚Üí "));

      navRoute = await fetchRouteGeoJSON(allCoords, mapboxgl.accessToken);
      steps = flattenSteps(navRoute);

      try {
        if (navRoute?.geometry?.type === "LineString") routeLine = turf.lineString(navRoute.geometry.coordinates);
        else routeLine = null;
      } catch {
        routeLine = null;
      }

      stepIdx = 0;

      clearRoute(map, "navRoute", "navRouteLine");
      drawRoute(map, navRoute.geometry, "navRoute", "navRouteLine");
      fitToRoute(map, navRoute.geometry, 60);

      navActive = true;
      followUser = true;
      freezeMarker = false; // ensure marker smoothing is active in nav mode
      recenterFab.style.display = "none";

      if (arrowMapboxMarker) arrowMapboxMarker.getElement().classList.add("arrow-active");

      updateNavUI();

      if (headingDeg != null) updateCamera(smoothPos || userPos);
    }

    grabArea.addEventListener("click", () => {
      bottomSheet.classList.toggle("expanded");
    });

    btnEnd.addEventListener("click", (e) => {
      e.stopPropagation();
      navActive = false;
      followUser = false;
      freezeMarker = false;

      if (arrowMapboxMarker) arrowMapboxMarker.getElement().classList.remove("arrow-active");

      clearRoute(map, "navRoute", "navRouteLine");
      window.location.href = "index.html";
    });

    // ===== NEW: freeze marker during user interaction to eliminate ‚Äúfloat‚Äù =====
    function onUserInteractStart() {
      followUser = false;
      freezeMarker = true;

      // nail marker to true GPS immediately
      if (arrowMapboxMarker && userPos) arrowMapboxMarker.setLngLat(userPos);

      recenterFab.style.display = "flex";
    }

    map.on("dragstart", onUserInteractStart);
    map.on("rotatestart", onUserInteractStart);
    map.on("pitchstart", onUserInteractStart);
    map.on("zoomstart", onUserInteractStart);

    recenterFab.addEventListener("click", () => {
      followUser = true;
      freezeMarker = false; // resume smoothing
      recenterFab.style.display = "none";
      updateCamera(smoothPos || userPos);
      applyHeadingToArrow();
    });

    btnEnableGPS.addEventListener("click", async () => {
      log("Enable GPS clicked");

      if (!navigator.geolocation) {
        alert("Geolocation not supported.");
        return;
      }

      try {
        await enableHeadingSensorsIfNeeded();
        window.addEventListener("deviceorientationabsolute", handleDeviceOrientation, true);
        window.addEventListener("deviceorientation", handleDeviceOrientation, true);

        await new Promise(res => setTimeout(res, 50));

        navigator.geolocation.getCurrentPosition(async pos => {
          const realPos = [pos.coords.longitude, pos.coords.latitude];

          userPos = urlOverrideStart ? urlOverrideStart.slice() : realPos;
          log("GPS OK:", userPos.toString());

          gpsTarget = userPos.slice();
          smoothPos = userPos.slice();

          const el = document.createElement("div");
          el.className = "arrow-marker";

          const rotor = document.createElement("div");
          rotor.className = "arrow-rotor";
          el.appendChild(rotor);
          arrowRotorEl = rotor;

          arrowMapboxMarker = new mapboxgl.Marker(el).setLngLat(userPos).addTo(map);

          map.jumpTo({ center: userPos, zoom: 16, pitch: 55, bearing: headingDeg ?? 0 });
          applyHeadingToArrow();

          if (!animStarted) {
            animStarted = true;
            requestAnimationFrame(animate);
          }

          navigator.geolocation.watchPosition(p => {
            const newPos = [p.coords.longitude, p.coords.latitude];
            userPos = urlOverrideStart ? urlOverrideStart.slice() : newPos;

            // Update target regardless; smoothing may be frozen (user panning)
            gpsTarget = userPos.slice();

            // If user is panning, keep marker nailed to true GPS, not smoothed pos
            if (freezeMarker && arrowMapboxMarker) arrowMapboxMarker.setLngLat(userPos);

            const gpsHeading = p.coords.heading;
            const gpsSpeed = p.coords.speed;
            if (typeof gpsHeading === "number" && gpsSpeed != null && gpsSpeed > 1.0) {
              headingDeg = norm360(gpsHeading);
            }

            applyHeadingToArrow();

            if (navActive) {
              maybeAdvanceStep();
              updateNavUI();
              maybeReroute();
            }
          }, e => err("watchPosition:", e.message), {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 20000
          });

          gpsOverlay.style.display = "none";
          await buildRouteFromUser();

        }, error => {
          err("GPS initial error:", error.message);
          alert("Location permission required.");
        }, { enableHighAccuracy: true, timeout: 12000 });

      } catch (e) {
        err("Enable GPS exception:", e);
      }
    });

  </script>

  <!-- SW -->
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/service-worker.js")
        .then(reg => console.log("SW registered:", reg.scope))
        .catch(err => console.error(err));
    }
  </script>

</body>
</html>
